---
layout: tutorial
title: Implementing the cursor pagination
description: Discover cursor pagination. The react app will access our appwrite backend using cursor pagination.
step: 8
---
In this step, we will discover how to add the cursor pagination method to our app.

# What is cursor pagination? {% #what-is-cursor-pagination %}

Cursor pagination uses a cursor that is a unique identifier(often a timestamp, ID, or some other field that has a consistent order) for a specific document, which acts as a pointer to the next document we want to start querying from to get the next page of data. For example, if you have a dataset of blog posts ordered by their creation date, and you want to retrieve post after a specific data, you would use that date as the cursor.

In Appwrite, cursor pagination uses either the `Query.cursorAfter(lastId)` query method to retrieve the next page of documents or the `Query.cursorBefore(firstId)` query method to retrieve the previous page of documents. Here is an example using Appwrite's `listDocuments()` command to retrieve the next page of documents.

```js
const page2 = await databases.listDocuments(
    '[DATABASE_ID]',
    '[COLLECTION_ID]',
    [
        Query.limit(25),
        Query.cursorAfter(lastId),
    ]
);
```

# Implementation {% #implementation %}

## Task context {% #task-context %}

By updating the contents of `src/lib/context/tasks.jsx` with the following code, replacing `[YOUR_DATABASE_ID]` and `[YOUR_COLLECTION_ID]` with your project ID and collection ID.

```js
import { createContext, useContext, useEffect, useState } from "react";
import { databases } from "../appwrite";
import { Query } from "appwrite";

export const TODOS_DATABASE_ID = "[YOUR_DATABASE_ID]";
export const TODOS_COLLECTION_ID = "[YOUR_COLLECTION_ID]";

const TasksContext = createContext();

export function useTasks() {
  return useContext(TasksContext);
}

export function TasksProvider(props) {
  const [tasks, setTasks] = useState([]);
  const [lastId, setLastId] = useState(null);
  const [firstId, setFirstId] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [counts, setCounts] = useState({
    totalPages: 500,
    totalResults: 1000,
  });
  const pageLimit = 4;
  const hasNext = counts.totalPages > currentPage;

  async function loadMore() {
    console.log("loading more...");
    try {
      if (hasNext) {
        const response = await databases.listDocuments(
          TODOS_DATABASE_ID,
          TODOS_COLLECTION_ID,
          [
            Query.orderDesc("$createdAt"),
            Query.limit(pageLimit),
            Query.cursorAfter(lastId),
          ],
        );
        setCurrentPage((currentPage) =>
          Math.min(currentPage + 1, counts.totalPages),
        );
        setFirstId(response.documents[0].$id);
        setLastId(response.documents[response.documents.length - 1].$id);
        setTasks(response.documents);
      }
    } catch (error) {
      console.log(error);
    }
  }
  async function loadPrev() {
    console.log("loading previous...");
    try {
      if (hasNext) {
        const response = await databases.listDocuments(
          TODOS_DATABASE_ID,
          TODOS_COLLECTION_ID,
          [
            Query.orderDesc("$createdAt"),
            Query.limit(pageLimit),
            Query.cursorBefore(firstId),
          ],
        );
        setCurrentPage((currentPage) => Math.max(currentPage - 1, 1));
        setFirstId(response.documents[0].$id);
        setLastId(response.documents[response.documents.length - 1].$id);
        setTasks(response.documents);
      }
    } catch (error) {
      console.error(error);
    }
  }
  async function init() {
    try {
      const response = await databases.listDocuments(
        TODOS_DATABASE_ID,
        TODOS_COLLECTION_ID,
        [Query.orderDesc("$createdAt"), Query.limit(pageLimit)],
      );
      setFirstId(response.documents[0].$id);
      setLastId(response.documents[response.documents.length - 1].$id);
      setTasks(response.documents);
      setCounts({
        totalPages: response.total / pageLimit,
        totalResults: response.total,
      });
    } catch (error) {
      console.log(error);
    }
  }
  useEffect(() => {
    init();
  }, []);

  return (
    <TasksContext.Provider
      value={{
        current: tasks,
        loadMore,
        loadPrev,
        currentPage,
        hasNext,
      }}>
      {props.children}
    </TasksContext.Provider>
  );
}
```

## Tasks page {% #tasks-page %}

To utilize cursor pagination in our app, we want a "load more" button that will allow us to load the next page of data. We also have a way to show the current page too. We will add these pieces of the UI to the Tasks page and use the `useTasks` hook to handle the loading of the next page and have the following:
* a "load previous" button that will handle the loading of the previous page of data and disabled when the current page is 1.
* a div that will show the current page when data is loaded
* a "load more" button that will handle loading the next page of data and disabled when the current page number is equal to the total number of pages.

Update the Tasks page in `src/pages/Tasks.jsx` to the following:
```js
import { useEffect, useState, useCallback } from "react";
import { useTasks } from "../lib/context/tasks";
export function Tasks() {
 const tasks = useTasks();
 return (
    <section>
      <h2>Todos</h2>
      <button
        disabled={tasks.currentPage === 1}
        onClick={() => tasks.loadPrev()}>
        Load Previous
      </button>
      <ul>
        {tasks.current &&
          tasks.current.map((task) => (
            <li key={`task-${task.taskId}`}>
              <span>{`Task-${task.taskId}: `}</span>
              <input type='checkbox' id={task.taskId} name={task.title} />
              <label htmlFor={task.title}>{task.title}</label>
            </li>
          ))}
      </ul>
      <button disabled={!tasks.hasNext} onClick={() => tasks.loadMore()}>
        Load More
      </button>
      <div>{tasks.currentPage}</div>
    </section>
  );
}
```